.. _lan_c_data:

数据结构
===============

.. contents::
    :local:


简介
-----------

分类
~~~~~~~~~~~~

* 数组
* 栈
* 队列
* 链表
* 树
* 图
* 字典树（这是一种高效的树形结构，但值得单独说明）
* 散列表（哈希表）


指针
-----------

.. contents::
    :local:

* 有10个指针的数组，该指针指向一个整数：int* a[10]
* 指向有10个整型数组的指针：int (* a)[10]
* 函数指针：一个指向函数的指针，该函数有一个整形参数并返回一个整形数：int (*func)(int)

函数指针
~~~~~~~~~~~~~~

声明形式：type (*func)(参数列表)

如果在程序中定义了一个函数，那么在编译时系统就会为这个函数代码分配一段存储空间，这段存储空间的首地址称为这个函数的地址。而且函数名表示的就是这个地址。
既然是地址我们就可以定义一个指针变量来存放，这个指针变量就叫作函数指针变量，简称函数指针。

.. code-block:: bash

    int(*p)(int, int);

这个语句就定义了一个指向函数的指针变量 p。首先它是一个指针变量，所以要有一个“*”，即（*p）；其次前面的 int 表示这个指针变量可以指向返回值类型为 int 型的函数；后面括号中的两个 int 表示这个指针变量可以指向有两个参数且都是 int 型的函数。所以合起来这个语句的意思就是：定义了一个指针变量 p，该指针变量可以指向返回值类型为 int 型，且有两个整型参数的函数。p 的类型为 int(*)(int，int)。

指向函数指针数组的指针声明形式：type (* (*func )[ ])(参数列表)

其中(* pfunarr2)[3]表示数组指针，而void(* )( )表示函数指针，两者结合起来就是指向函数指针数组的指针。

指针函数
^^^^^^^^^^^^^^

声明形式：type *func (参数列表)

指针函数就是返回指针值的函数，本质是一个函数。所以指针函数等价于“返回值为指针的函数”。

从上面的定义形式可以看出，函数指针和指针函数的直观上区别在于指针符号*与函数名/指针名有没有用括号（）包裹起来，从这一点来看是很容易区分两者的。


数组
-----------

.. contents::
    :local:

零长数组
~~~~~~~~~~~~~~

今天在看代码中遇到一个结构中包含char data[0]，第一次见到时感觉很奇怪，数组的长度怎么可以为零呢？于是上网搜索一下这样的用法的目的，发现在linux内核中，结构体中经常用到data[0]。
这样设计的目的是让数组长度是可变的，根据需要进行分配。方便操作，节省空间。

.. code-block:: bash

    struct buffer
    {
        int data_len;   //长度
        char data[0];  //起始地址
    };

在这个结构中，data是一个数组名；但该数组没有元素；该数组的真实地址紧随结构体buffer之后，而这个地址就是结构体后面数据的地址（如果给这个结构体分配的内容大于这个结构体实际大小，后面多余的部分就是这个data的内容）；这种声明方法可以巧妙的实现C语言里的数组扩展。

对比指针
^^^^^^^^^^^^^^

从结果可以看出data[0]和data[]不占用空间，且地址紧跟在结构后面，而char *data作为指针，占用4个字节，地址不在结构之后。

在实际程序中，数据的长度很多是未知的，这样通过变长的数组可以方便的节省空间。对指针操作，方便数据类型的转换。

采用char *data，需要进行二次分配，操作比较麻烦，很容易造成内存泄漏。而直接采用变长的数组，只需要分配一次，然后进行取值即可以。


链表
-----------

.. contents::
    :local:

链表是一系列的元素连接在一起形成的数据结构。在c语言中，链表是用指针来构建的。使用链表数据结构是使用内存操作比较的一种方式。二叉树是链表的延伸。它的每一个节点都有两个指针，一个指向左，一个指向右。

