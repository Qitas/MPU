.. _lan_c_data:

数据结构
===============

.. contents::
    :local:
    :depth: 1


指针
-----------

.. toctree::
    :maxdepth: 1

    指针概念 <pointer>


数组
-----------


零长数组
~~~~~~~~~~~~~~

今天在看代码中遇到一个结构中包含char data[0]，第一次见到时感觉很奇怪，数组的长度怎么可以为零呢？于是上网搜索一下这样的用法的目的，发现在linux内核中，结构体中经常用到data[0]。
这样设计的目的是让数组长度是可变的，根据需要进行分配。方便操作，节省空间。

.. code-block:: bash

    struct buffer
    {
        int data_len;   //长度
        char data[0];  //起始地址
    };

在这个结构中，data是一个数组名；但该数组没有元素；该数组的真实地址紧随结构体buffer之后，而这个地址就是结构体后面数据的地址（如果给这个结构体分配的内容大于这个结构体实际大小，后面多余的部分就是这个data的内容）；这种声明方法可以巧妙的实现C语言里的数组扩展。

对比指针
^^^^^^^^^^^^^^

从结果可以看出data[0]和data[]不占用空间，且地址紧跟在结构后面，而char *data作为指针，占用4个字节，地址不在结构之后。

在实际程序中，数据的长度很多是未知的，这样通过变长的数组可以方便的节省空间。对指针操作，方便数据类型的转换。

采用char *data，需要进行二次分配，操作比较麻烦，很容易造成内存泄漏。而直接采用变长的数组，只需要分配一次，然后进行取值即可以。


链表
-----------

链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。

链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。

相比于线性表顺序结构，操作复杂。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而线性表和顺序表相应的时间复杂度分别是O(logn)和O(1)。

使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。

链表最明显的好处就是，常规数组排列关联项目的方式可能不同于这些数据项目在记忆体或磁盘上顺序，数据的存取往往要在不同的排列顺序中转换。

链表允许插入和移除表上任意位置上的节点，但是不允许随机存取。链表有很多种不同的类型：单向链表，双向链表以及循环链表。

* 双向链表其实是单链表的改进。在双向链表中，结点除含有数据域外，还有两个链域，一个存储直接后继结点地址，一般称之为右链域；一个存储直接前驱结点地址，一般称之为左链域。
* 循环链表是与单链表一样，是一种链式的存储结构，所不同的是，循环链表的最后一个结点的指针是指向该循环链表的第一个结点或者表头结点，从而构成一个环形的链。

.. toctree::
    :maxdepth: 1

    链表实现 <list>

其他
-----------

* :ref:`lan_c_stack`
* 队列
* 树
* 图
* 字典树（这是一种高效的树形结构，但值得单独说明）
* 散列表（哈希表）

