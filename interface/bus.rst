.. _bus:

高速通信
===============

.. contents::
    :local:
USB
-----------

USB（Universal Serial Bus）全称通用串口总线，支持热插拔。

USB协议版本有USB1.0、USB1.1、USB2.0、USB3.1等，USB2.0目前比较常用。

.. toctree::
    :maxdepth: 1

    USB  <usb>

.. _ethernet:

Ethernet
-----------

`Xin推荐 <https://docs.soc.xin/for/iot.html#id8>`_


.. toctree::
    :maxdepth: 1

    LwIP  <LwIP>


SerDes
-----------

在传统的源同步传输中，数据和时钟分离，在速率较低(<1000M)时问题不大,在传输速率越来越高时，由于传输线的时延和抖动存在（个人理解为时序约束中的routing布线延迟和时钟Jitter（也就是时钟周期差异）），导致接收端不能正确的采样数据，时钟边沿无法与数据中心对齐。


CDR
~~~~~~~~~~~~~~

CDR(Clock Data Recovery) 时钟恢复电路一般是通过PLL电路（鉴相器PD、环路滤波器LF、压控振荡器VCO）实现，其作用是从数据流中准确的恢复出时钟和数据信息。

参考时钟输入到鉴相器(PD)，鉴相器比较的是两个相位，一个是参考时钟，一个是数据恢复时钟，两个时钟之间存在两种差异，一种是频率差，另一种是相位差，当恢复时钟相位与参考时钟相位之间存在差异的话会产生一个对应比例的积分值，根据积分值的大小，控制数据时钟提取电路的时钟进行偏移，从而使得数据恢复时钟和参考时钟相位进行对齐，此时认为输出时钟锁定，即所向为认为时钟已经锁定到了所需要的相位或者频点上，就可以作为一个可以使用的时钟。

.. warning::
    这里的对齐和锁定，也是指的在允许范围内的对齐和锁定,可以允许有偏差存在。

Comma
~~~~~~~~~~~~~~

在serdes上的高速串行数据流在接收端需要重新串并转换成多个字节的并行数据，如何有效的识别32bit数据边界？这就需要一个特殊的序列，即为Comma码。在任意数据组合中，Comma码只作为控制字符出现，在数据负荷部分不会出现，所以使用comma码字符只是帧的开始和结束标志，或者修正和数据流对齐的控制字符。

接收器在输入数据流中扫描搜寻特定的比特序列（comma），如果找到序列，解串器调整字符边界以匹配检测到的Comma字符序列。


PCIe
-----------


编码效率
~~~~~~~~~~~~~~

我们一般谈论的PCIE带宽，采用GT/s为单位表示，也即PCIE总线上实际编码后发送的数据速率。

因为PCIe是一条串行总线，数据中嵌入了时钟，它需要确保发生足够的电平转换（1到0和0到1），以便接收端恢复时钟。

为了增加电平转换，PCIe使用了 “8b/10b “编码，即每8个bit（1个字节）被编码成一个10 bit 的符号进行传输，然后在接收端进行解码。因此，总线需要传输10 bit的编码数据来表示所发送的8 bit的数据。而到了PCIE 3.0 标准，编码方案为128b/130b编码，也即每128 bit的数据编码为130 bit的符号进行传输。

以每条PCIe 1.0 lane 为例，PCIe是全双工的总线，一个lane由两对差分信号线，即4根信号线组成。

双向总线在每个方向上可以每秒传输 2.5 Gbit，全双工即5 Gbit, 也即全双工每秒传输 5GT/s。

由于总线每传送的8bit未编码数据需要转换为10 bit的编码数据来传送，其有效带宽为GT(Gigatransfer) x Lane的数量 x 编码方案效率

用上边 PCIe 1.0 单条 lane 单个方向的速率为例，代入数据：2.5 GT x 1 lane x (8/10 的编码方案效率) = 2Gbps ÷ 8 = 250MB/s。

而一条16通道的PCIe 1.0 总线，每秒传输 40 GT/s，有效带宽  32 Gbps，到了 PCIE 3.0, 编码方案为 128b/130b，效率得到的很大的提高。


.. note::
    PCI-E 每 lane是全双工传输，这里给出的速率是单个方向的速率

